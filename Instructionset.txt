Registers (default size 8-bit):
General purpose:	A, B, C, D					regbank
Internal registers:	IROP (Instruction register)			control unit
			INPC (Program Counter)				program counter
			IMMA (IMM16 Address Buffer, 16 bit)		program counter
Flags (1 bit):		Carry, Zero, Sign				alu unit

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~( only 0)~~~~~~~~~~~PCjump=1, PCjrel=IROP[3]
( 0)0000####	JMP ...
		Byte order: [JMPOP][ADDRLO][ADDRHI][...]
		At Cycle 2, addrHi/addrLo will be pointing at ADDRHI
		and the value can be copied from MemBus into PC
	000F	JMP IMM16	if 0=F		(JMP, NOP)		PC2addr=1
	001F	JMP IMM16	if Carry=F	(JNC, JC)
	010F	JMP IMM16	if Zero=F	(JNZ, JZ)
	011F	JMP IMM16	if Sign=F	(JNS, JS)
		At Cycle 1, address will be pointing at REL8
		and the value can be copied from MemBus into PC
	100F	JMP REL8	if 0=F		(JMP, NOP)
	101F	JMP REL8	if Carry=F	(JNC, JC)
	110F	JMP REL8	if Zero=F	(JNZ, JZ)
	111F	JMP REL8	if Sign=F	(JNS, JS)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
( 1)0001####
	00YY	LD  [IMM16], DST					Mem2ModBus=1, Mem_WR=0
	01YY	ST  SRC, [IMM16]					Mem2ModBus=0, Mem_WR=1
		When Mem2IMLo=1, immaHi is set to zero
	10YY	LD  [IMM8], DST			Zeropage		Mem2ModBus=1, Mem_WR=0
	11YY	ST  SRC, [IMM8]			Zeropage		Mem2ModBus=0, Mem_WR=1
( 2)0010####
	000Y	LD  [C:D], A/B
	001Y	ST  A/B, [C:D]
	01##	...
	1###	...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
( 3)0011####	...
( 4)0100####	...
( 5)0101####	...
( 6)0110####	...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(7 to 15)~~~~~~~~~~~ALU_OE=1, DstSel=YY, ModSel=XX, Mod2ModBus=1
( 7)0111XXYY	MOV SRC, DST						ALUBus2Dst=1, ALU_Nop=1, F_Store=0
	XXYY	MOV IMM8, DST		(if XX==YY)
( 8)1000XXYY	CMP MOD, DST						ALUBus2Dst=0, ALU_OP=ADD, InvertMod=1, F_Store=1, ALU_Carry=0
	XXYY	CMP IMM8, DST		(if XX==YY)
( 9)1001XXYY	SUB MOD, DST						ALUBus2Dst=1, ALU_OP=ADD, InvertMod=1, F_Store=1, ALU_Carry=0
	XXYY	SUB IMM8, DST		(if XX==YY)
(10)1010XXYY	SBC MOD, DST						ALUBus2Dst=1, ALU_OP=ADD, InvertMod=1, F_Store=1, ALU_Carry=Carry
	XXYY	SBC IMM8, DST		(if XX==YY)
(11)1011XXYY	ADC MOD, DST						ALUBus2Dst=1, ALU_OP=ADD, InvertMod=0, F_Store=1, ALU_Carry=Carry
	XXYY	ADC IMM8, DST		(if XX==YY)
(12)1100XXYY	ADD MOD, DST						ALUBus2Dst=1, ALU_OP=ADD, InvertMod=0, F_Store=1, ALU_Carry=0
	XXYY	ADD IMM8, DST		(if XX==YY)
(13)1101XXYY	XOR MOD, DST						ALUBus2Dst=1, ALU_OP=XOR, InvertMod=0, F_Store=1, ALU_Carry=(*)
(14)1110XXYY	AND MOD, DST						ALUBus2Dst=1, ALU_OP=AND, InvertMod=0, F_Store=1, ALU_Carry=(*)
	XXYY	AND IMM8, DST		(if XX==YY)
(15)1111XXYY	OR  MOD, DST						ALUBus2Dst=1, ALU_OP=OR,  InvertMod=0, F_Store=1, ALU_Carry=(*)
	XXYY	OR  IMM8, DST		(if XX==YY)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Unmapped/unimplemented instructions

	DCNN	D = direction R/L, C = Through Carry, NN = 1, 2, 3 or 4 bits
	00NN	SHR A, NN			Shift Right with Zero
	01NN	ROR A, NN			Shift Right through Carry
	10NN	SHL A, NN			Shift Left  with Zero
	11NN	ROL A, NN			Shift Left  through Carry

	00YY	INC DST				ADC constant ZERO + Carry=1
	01YY	DEC DST				SBC constant ZERO - Carry=1
		DEC is equivalent to NOT(INC(NOT(X)))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* --> Value doesnt affect result

OP/Cycle		[IROP]	[IRLO]	[IRHI]	[Memory]

JMP IMM16		  X	  X	  X	  -
JMP REL8		  X	  X	  -	  -
LD  [IMM16], DST	  X	  X	  X	  X
ST  SRC, [IMM16]	  X	  X	  X	  X
LD  [IMM8], DST		  X	  X	  -	  X
ST  SRC, [IMM8]		  X	  X	  -	  X
LD  [C:D], A/B		  X	  -	  -	  X
ST  A/B, [C:D]		  X	  -	  -	  X
ALU IMM8, DST		  X	  X	  -	  -
MOV IMM8, DST		  X	  X	  -	  -
MOV SRC, DST		  X	  -	  -	  -
ALU SRC, DST		  X	  -	  -	  -

